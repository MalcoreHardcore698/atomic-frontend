{"ast":null,"code":"var _s2 = $RefreshSig$();\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { useState, useEffect } from 'react';\nexport var useInfiniteScroll = function useInfiniteScroll(_ref) {\n  _s2();\n\n  var callbackOnTop = _ref.callbackOnTop,\n      callbackOnBottom = _ref.callbackOnBottom,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? 50 : _ref$offset;\n\n  var _useState = useState(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      lastScrollTop = _useState2[0],\n      setLastScrollTop = _useState2[1];\n\n  useEffect(function () {\n    var scrollElement = document.documentElement;\n\n    var onScroll = function onScroll() {\n      if (!scrollElement) return;\n      var dir = scrollElement.scrollTop - lastScrollTop;\n\n      if (callbackOnBottom && dir > 0 && scrollElement.scrollTop + scrollElement.clientHeight >= scrollElement.scrollHeight - offset) {\n        callbackOnBottom(scrollElement.scrollTop, scrollElement.scrollHeight);\n      }\n\n      if (callbackOnTop && dir < 0 && scrollElement.scrollTop <= offset) {\n        callbackOnTop(scrollElement.scrollTop, scrollElement.scrollHeight);\n      }\n\n      setLastScrollTop(scrollElement.scrollTop);\n    };\n\n    if (scrollElement) {\n      window.addEventListener('scroll', onScroll);\n    }\n\n    return function () {\n      if (scrollElement) {\n        window.removeEventListener('scroll', onScroll);\n      }\n    };\n  }, [callbackOnTop, callbackOnBottom, offset]);\n};\n\n_s2(useInfiniteScroll, \"Ysq8Rfde3lcEiwMxYcg8Kq62XXo=\");\n\nexport default useInfiniteScroll;","map":{"version":3,"sources":["C:/Users/dan82/Documents/workspace/FREELANCE/atomic/atomic-frontend/hooks/useInfiniteScroll.js"],"names":["useState","useEffect","useInfiniteScroll","callbackOnTop","callbackOnBottom","offset","lastScrollTop","setLastScrollTop","scrollElement","document","documentElement","onScroll","dir","scrollTop","clientHeight","scrollHeight","window","addEventListener","removeEventListener"],"mappings":";;;;;;;;;;;;;;AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AAEA,OAAO,IAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,OAAsD;AAAA;;AAAA,MAAnDC,aAAmD,QAAnDA,aAAmD;AAAA,MAApCC,gBAAoC,QAApCA,gBAAoC;AAAA,yBAAlBC,MAAkB;AAAA,MAAlBA,MAAkB,4BAAT,EAAS;;AAAA,kBAC3CL,QAAQ,CAAC,CAAD,CADmC;AAAA;AAAA,MAC9EM,aAD8E;AAAA,MAC/DC,gBAD+D;;AAGrFN,EAAAA,SAAS,CAAC,YAAM;AACd,QAAMO,aAAa,GAAGC,QAAQ,CAACC,eAA/B;;AAEA,QAAMC,QAAQ,GAAG,SAAXA,QAAW,GAAM;AACrB,UAAI,CAACH,aAAL,EAAoB;AACpB,UAAMI,GAAG,GAAGJ,aAAa,CAACK,SAAd,GAA0BP,aAAtC;;AAEA,UACEF,gBAAgB,IAChBQ,GAAG,GAAG,CADN,IAEAJ,aAAa,CAACK,SAAd,GAA0BL,aAAa,CAACM,YAAxC,IAAwDN,aAAa,CAACO,YAAd,GAA6BV,MAHvF,EAIE;AACAD,QAAAA,gBAAgB,CAACI,aAAa,CAACK,SAAf,EAA0BL,aAAa,CAACO,YAAxC,CAAhB;AACD;;AACD,UAAIZ,aAAa,IAAIS,GAAG,GAAG,CAAvB,IAA4BJ,aAAa,CAACK,SAAd,IAA2BR,MAA3D,EAAmE;AACjEF,QAAAA,aAAa,CAACK,aAAa,CAACK,SAAf,EAA0BL,aAAa,CAACO,YAAxC,CAAb;AACD;;AAEDR,MAAAA,gBAAgB,CAACC,aAAa,CAACK,SAAf,CAAhB;AACD,KAhBD;;AAkBA,QAAIL,aAAJ,EAAmB;AACjBQ,MAAAA,MAAM,CAACC,gBAAP,CAAwB,QAAxB,EAAkCN,QAAlC;AACD;;AAED,WAAO,YAAM;AACX,UAAIH,aAAJ,EAAmB;AACjBQ,QAAAA,MAAM,CAACE,mBAAP,CAA2B,QAA3B,EAAqCP,QAArC;AACD;AACF,KAJD;AAKD,GA9BQ,EA8BN,CAACR,aAAD,EAAgBC,gBAAhB,EAAkCC,MAAlC,CA9BM,CAAT;AA+BD,CAlCM;;IAAMH,iB;;AAoCb,eAAeA,iBAAf","sourcesContent":["import { useState, useEffect } from 'react'\n\nexport const useInfiniteScroll = ({ callbackOnTop, callbackOnBottom, offset = 50 }) => {\n  const [lastScrollTop, setLastScrollTop] = useState(0)\n\n  useEffect(() => {\n    const scrollElement = document.documentElement\n\n    const onScroll = () => {\n      if (!scrollElement) return\n      const dir = scrollElement.scrollTop - lastScrollTop\n\n      if (\n        callbackOnBottom &&\n        dir > 0 &&\n        scrollElement.scrollTop + scrollElement.clientHeight >= scrollElement.scrollHeight - offset\n      ) {\n        callbackOnBottom(scrollElement.scrollTop, scrollElement.scrollHeight)\n      }\n      if (callbackOnTop && dir < 0 && scrollElement.scrollTop <= offset) {\n        callbackOnTop(scrollElement.scrollTop, scrollElement.scrollHeight)\n      }\n\n      setLastScrollTop(scrollElement.scrollTop)\n    }\n\n    if (scrollElement) {\n      window.addEventListener('scroll', onScroll)\n    }\n\n    return () => {\n      if (scrollElement) {\n        window.removeEventListener('scroll', onScroll)\n      }\n    }\n  }, [callbackOnTop, callbackOnBottom, offset])\n}\n\nexport default useInfiniteScroll\n"]},"metadata":{},"sourceType":"module"}